---
layout: post
title:  "[알고리즘] 🤑 Greedy 알고리즘"
date:   2020-03-09 18:34:10 +0700
categories: [algorithm]
---

> [동빈나 유튜브](https://www.youtube.com/watch?v=PNPIk3hc6ic&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=38) 영상과 [라이 블로그 - 탐욕적 기법](http://blog.naver.com/kks227/220775134486)을 참고하여 공부한 내용!

<br>

# 🤑 Greedy 알고리즘이란?

__"그리디(Greedy)"__ 라는 영어 단어의 뜻은 __"욕심"__ 이라는 뜻이다.

따라서 그리디 알고리즘이라는 것은 __당장 눈 앞에 보이는 최적의 상황만을 욕심내서 쫓는 알고리즘__ 이라고 할 수 있다.

그리디 알고리즘은 항상 최적의 결과를 도출하는 것은 아니지만 어느 정도 최적의 해에 __근사한 값__ 을 __빠르게__ 구할 수 있다는 점이 장점이다!

또한 어떤 특정한 상황에 있어서는 그리디 알고리즘이 최적의 해를 보장하기도 한다.

그리디 알고리즘의 대표적인 예제는 __거스름 돈 문제__ 이다.

거스름 돈 문제란?

사람들은 흔히 거스름 돈을 줘야할 때 가장 적은 양의 화폐를 주는 것이 편할 것이다. 

예를 들어 560원을 걸러주어야 하는 상황이라면 10원짜리 56개를 주는 사람은 거의 없다!

500원 짜리 1개, 50원 짜리 1개, 10원짜리 1개를 주는 것이 더 편하기 때문이다.

즉, 이런 상황에서는 '무조건 더 큰 화폐 단위부터 거슬러 준다' 라는 법칙만 지키면 가장 적은 양의 화폐(최적의 해)로 거슬러 줄 수 있게 된다.

따라서 그리디 알고리즘은 무조건 큰 것부터, 무조건 작은 것부터, 무조건 긴 것부터, 무조건 짧은 것부터 등으로 극단적으로 문제에 접근한다는 점이 특징이며 그로 인해 정렬(Sort) 기법이 함께 사용되는 경우가 많다!

이와 같이 그리디 알고리즘은 문제의 성질이 동일하게 보존되고, 같은 전략을 반복적으로 취할 수 있다는 특징을 가지고 있다.

실제로 그리디 알고리즘 기법이 사용되는 실생활적인 경우가 많기 때문에 알아두면 일상생활에서도 도움이 되는 경우가 많다!

<br>

# 🤑 Greedy 알고리즘의 동작 원리

위에서 설명한 거스름 돈 문제를 Greedy 알고리즘으로 풀어보자.

만약, 1260원을 거슬러주어야 할 때 가장 적은 숫자의 화폐를 이용해 거슬러 주려면 어떻게 해야할까? (거슬러 줄 수 있는 동전의 종류는 500원, 100원, 50원, 10원이 있다고 가정하자.)

무조건 큰 화폐로 거슬러 줄 수 있을 때까지 거슬러 주면 된다.

즉, 맨 먼저 500원짜리 2개를 거슬러 줄 수 있고 남은 금액인 260원 안에서 거슬러 줄 수 있는 가장 큰 화폐를 생각해본다.

260원 안에서 거슬러 줄 수 있는 가장 큰 화폐는 100원짜리이고 2개를 거슬러 줄 수 있다. 그럼 남은 금액은 60원이 된다.

마찬가지로 60원 안에서 거슬러 줄 수 있는 가장 큰 화폐는 50원이고 1개를 거슬러 줄 수 있다.

남은 금액인 10원 안에서 거슬러 줄 수 있는 가장 큰 화폐는 10원이고 1개를 거슬러 주면 거스름 돈 문제가 해결된다. 

이렇게 그리디 알고리즘은 단순하게 어떠한 한 가지 경우만 보고 쫓아간다는 의미로 탐욕적이라고 표현하기도 한다!

<br>

# 🤑 Greedy 알고리즘을 C++로 구현해보기

위에서 설명했던 거스름 돈 문제를 그리디 알고리즘 기법으로 해결해보자.

~~~c++
#include<iostream>
using namespace std;

int main(){
	// n은 거슬러 줘야 하는 돈의 금액  
	// result 는 총 몇 개의 동전으로 거슬러 줄 수 있는지 나타내는 변수  
	int n, result = 0;
	cin>>n;
	
	// 그리디 알고리즘 
	result += n / 500;
	n = n % 500;
	
	result += n / 100;
	n = n % 100;
	
	result += n / 50;
	n = n % 50;
	
	result += n / 10;
	
	cout<<result;
	
}
~~~

위와 같은 코드를 작성하면 결과값이 6으로 나오게 될 것이다.

하지만 그리디 알고리즘은 실제로는 최적의 해를 보장하지 경우도 많다. 그래서 다이나믹 프로그래밍(Dynamic Programming) 등의 다른 알고리즘 기법을 적용해서 풀어야 하는 경우도 있다.

또한, 그리디 알고리즘은 특성상 말로 풀이해보면 간단하지만 실제 코드 구현은 문제에 따라 차이가 나기도 한다!

<br>

> 끝끝끝~! 🤑🤑🤑

