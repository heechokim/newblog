---
layout: post
title:  "[알고리즘] ☝️ 👇 최대공약수 최소공배수 (feat. 유클리드 호제법)"
date:   2019-05-24 18:34:10 +0700
categories: [algorithm]
---

> [백준 2609번 - 최대공약수와 최소공배수](https://www.acmicpc.net/problem/2609) 
>
> 두 수의 최대공약수와 최소공배수를 구하는 소스코드를 분석해보자!

<br>

## 👀 최대공약수와 최소공배수 구하기

> 이 문제를 풀때 처음에는 for문으로 구현했었다. 
>
> 하지만 최대공약수, 최소공배수 구하는 문제는 for문으로 복잡하게 할 필요가 없다!
>
> 아래 코드를 보고 생각해보자.

<br>

~~~c
#include<stdio.h>

int gcd(int a, int b);
int lcm(int a, int b);

int main(){
	int n1, n2;
	scanf("%d %d", &n1, &n2);
	printf("%d\n%d", gcd(n1,n2), lcm(n1,n2));	
}

int gcd(int a, int b){
	int min, temp;
	
	min = (a<b)?a:b;
	
	for(int i = 1 ; i <= min ; i++){
		if(a%i == 0 && b%i == 0){
			temp = i;
		}
	}
	
	return temp;
} 

int lcm(int a, int b){
	int max, temp;
	
	max = (a>b)?a:b;
	
	for(int i = max ;; i++){
		if(i%a == 0 && i%b == 0){
			temp = i;
			break;
		}
	}
	
	return temp;
	
}
~~~

<br>

- _코드 설명_

	일단 코드를 보기 전에 최대공약수와 최소공배수의 의미를 다시한번 생각해보자!

	두 수의 __최대공약수__ 는 두 수의 공통된 약수 중 최대값을 의미한다.

	즉, __두 수를 모두 나누어 떨어지게 하는 수 중 최대값__ 이라는 것이다. 

	두 수의 __최소공배수__ 는 두 수의 공통된 배수 중 최솟값을 의미한다.

	> gcd = greatest common divisor 의 줄임말
	>
	> lcm = least common multiple의 줄임말

	<br>

	최대공약수 구하는 함수를 살펴보면

	~~~c
	int gcd(int a, int b){
	int min, temp;
	
	// a, b 중 작은 수 구하기
	// 삼항연산자 사용
	min = (a<b)?a:b;
	
	// 두 수를 1부터 작은 수까지의 수로 나눠본다.
	// 두 수를 모두 나누어 떨어지게 하는 수를 계속 temp 에 저장한다.
	// temp 가 계속 바뀌고, 최종적으로 min이하의 최댓값이 저장된다.
	for(int i = 1 ; i <= min ; i++){
		if(a%i == 0 && b%i == 0){
			temp = i;
		}
	}
	
	return temp;
	} 	
	~~~

	이다. __최대공약수는 1부터 두 수 중 작은 수 까지의 범위 내에 있을 수 밖에 없다!__ 라는 성질을 사용한 것이다.

	<br>

	최소공배수 구하는 함수를 살펴보면

	~~~c
	int lcm(int a, int b){
	int max, temp;
	
	// a, b 중 큰 수 구하기
	max = (a>b)?a:b;
	
	// 큰 수 부터 1씩 증가시키며 for문을 무한히 돌린다.
	// 증가되는 수를 두 수로 나눠본다.
	// 두 수로 모두 나누어 떨어지는 수가 있다면 for문을 빠져나온다.
	for(int i = max ;; i++){
		if(i%a == 0 && i%b == 0){
			temp = i;
			break;
		}
	}
	
	return temp;
	
	}
	~~~

	이다. __최소공배수는 두 수 중 큰 수와 같거나 클 수밖에 없다!__ 라는 성질을 사용한 것이다.

	그런데! 여기서 주의할 점이 있다! 만약 지금까지 알아본 방법으로 최소공배수, 최대공약수를 구하면 시간초과가 발생할 가능성이 크다!

	N = min(a, b) 라고 한다면 최대공약수 구하는 알고리즘의 시간복잡도는 __O(N)__ 이고, M = max(a, b) 라고 한다면 최소공배구 구하는 알고리즘의 시간복잡도는 __O(M)__ 이기 때문이다.

	만약 최대공약수를 구할 두 수가 1000000과 12222222이라면 두 수 중 최소값인 1000000번 for문이 돌아야한다.

	즉, 최대공약수, 최대공배수를 구하는 대상이 되는 두 수의 값이 클 경우에는 for문이 돌아가는 횟수가 많아져서 시간적으로 효율적이지 않게 된다!

	최대공약수와 최소공배수를 위와 같은 방법보다 더 빠르게 구할 수 있는 방법이 있는데 이 방법은 __유클리드 호제법__ 이라는 방법을 사용하는 것이다.

	<br>

## 👀 유클리드 호제법

- _유클리드 호제법이란?_

	2개의 수의 __최대공약수__ 를 구하는 방법으로 널리 알려져있는 방법이다!

	__호제법__ 이라는 말은 "2개의 수를 번갈아 가며 나누는 것" 이라는 뜻이다.

	__정수 X와 Y(X >= Y) 가 주어졌을 때, X를 Y로 나눈 나머지를 R(X % Y = R)이라고 하면, X와 Y의 최대공약수는 Y와 R의 최대공약수와 같다. 단, (Y % R) = 0일 경우 최대공약수는 Y이다.__ 

	로 정의할 수 있다.

	위 정의의 'X와 Y의 최대공약수는 Y와 R의 최대공약수와 같다' 는 말은 Y와 R의 최대공약수 또한, Y를 R로 나눈 나머지를 T라고 했을 때, R와 T의 최대공약수와 같다는 것이다!

	즉, X와 Y가 번갈아가며 나누어지고 있음을 알 수 있다. 

	아래 예시를 보면서 이해해보자.

	![호제법](https://user-images.githubusercontent.com/31889335/62542402-aa1ad080-b896-11e9-9d7c-318fd046acc5.PNG)

	위 그림에서 4와 0이 남았으므로 28과 24의 최대공약수는 4이다.

	이러한 방법의 유클리드 호제법을 코드로 작성해보면 (위 예시를 보면서 작성하면 쉽다.)

	<br>

	~~~c
	#include<stdio.h>

	void GCD(int a, int b);
	int main(){
		// 28과 24의 최대공약수
		GCD(28, 24);
	}

	void GCD(int a, int b){
		int tmp = a;
		a = b;
		b = tmp%b;
		if(b == 0){
			printf("최대공약수는 %d", a);
			return;
		}
		GCD(a, b);
	}
	~~~

	로 작성할 수 있다!

	위 코드를 재귀함수로 나타내면

	~~~c++
	int gcd(int a, int b) {
		if(b == 0) {
			// 최대공약수가 a 이다.
			return a;
		} else {
			gcd(b, a%b);
		}
	}
	~~~

	로 나타낼 수 있다.

	이러한 유클리드 호제법의 시간복잡도는 __O(logN)__ 이기 때문에 훨씬 빠르게 최대공약수를 찾아낼 수 있다.

- __그럼 최소 공배수는 어떻게 구할 수 있을까?__

	유클리드 호제법으로 최대공약수를 구한 후, __A * B = GCD(A, B) * LCM(A, B)__ 라는 수식이 성립함을 응용하여 최소공배수를 구하면 된다.

	어떤 두 수의 곱은 이 두 수의 최대공약수와 최소공배수를 곱한 것과 같다.

	따라서 최소공배수를 구하기 위해서는 A와 B를 곱한 값에 유클리드 호제법으로 구한 최대공약수를 나누어주면 된다!

## 생각생각

> 🙀 함수로 기능을 묶어서 구현하는 것이 더 편할 때도 있군!
>
> 함수로 구현할 때는 main 함수 위에 함수를 __정의__ 해주고, main 함수 밑에 함수를 구현하는 방법과 애초에 main 함수 위에 함수를 구현하는 방법이 있다!
>
> 함수를 정의한다는 것은 __함수의 반환값과 함수 이름, 함수 인자(변수의 자료형까지 명시)__ 이 3가지를 명시해주는 것~!


	
